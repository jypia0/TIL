# Git 실전 흐름과 원론적 구조 정리

> **학습 목적:** 이 문서는 Git을 단순히 사용하는 수준을 넘어, Git이 작동하는 내부 원리와 설계 철학까지 이해하고자 하는 사람들을 위한 실전 중심의 학습 자료입니다.  
> 실무 프로젝트나 협업 상황에서 오류를 예방하고, 면접에서 Git을 원리 수준으로 설명할 수 있도록 구성되었습니다.

---

## 1단계: 디렉토리 이동

```bash
cd <폴더 경로>
```
- `cd` = Change Directory: 작업을 수행할 디렉토리(폴더)로 이동
- Git은 해당 폴더 안에서 `.git` 디렉토리를 통해 모든 버전 정보를 추적하기 때문에, **작업 디렉토리를 정확히 설정하는 것이 중요**
- 💡 **운영체제별 차이**:
  - Windows: `cd C:\Users\jypia\Desktop\프로젝트`
  - macOS/Linux: `cd ~/Desktop/프로젝트`


## 2단계: Git 저장소 초기화

```bash
git init
```
- 현재 디렉토리를 Git 저장소로 선언
- `.git` 디렉토리 생성됨 → Git의 핵심 데이터베이스

#### `.git` 내부 구조
```
.git/
├── config        # 저장소 설정 정보
├── HEAD          # 현재 브랜치가 어떤 커밋을 가리키는지
├── objects/      # 커밋, 트리, 블롭 등의 실제 내용 저장소
├── refs/         # 브랜치, 태그의 포인터들
└── index         # 스테이징 영역 (Staging Area)
```


## 3단계: 현재 Git 상태 확인

```bash
git status
```
- 작업 디렉토리, 스테이징 영역, 커밋 여부 등의 상태를 확인함

### Git의 3단계 작업 공간
| 구분 | 의미 | 되돌리기 명령 |
|------|------|----------------|
| Working Directory | 실질적으로 파일을 수정하는 공간 | `git restore <파일>` |
| Staging Area | 커밋할 파일을 잠시 보관하는 공간 | `git restore --staged`, `git rm --cached` |
| Repository | 커밋된 스냅샷이 저장되는 영역 | `git commit --amend` |

> ❗ `git restore`는 복원이 불가할 수 있으므로 주의


## 4단계: 커밋에 포함할 파일 선택

```bash
git add .
```
- 현재 디렉토리 내 **모든 변경 파일을 스테이징**에 추가함
- 부분적으로 추가하고 싶다면 `git add 파일명` 형식으로도 가능


## 5단계: 커밋 수행

```bash
git commit -m "초기 구조 커밋"
```
- 스테이징 영역의 변경 사항을 커밋하여 **하나의 버전으로 기록**함
- 커밋의 상태:
  - Untracked: 추적되지 않는 새 파일
  - Unmodified: 추적되지만 변경되지 않음
  - Modified: 변경되었지만 스테이징되지 않음
  - Staged: 커밋 대상에 올라간 상태

> 커밋은 Git의 핵심 단위로, 하나의 **스냅샷 시점**이라고 볼 수 있음


## 커밋 되돌리기

### `git reset`
```bash
git reset [--soft | --mixed | --hard] <커밋ID>
```
- soft: 커밋만 취소하고 변경 내용은 Staging에 남김
- mixed (기본): 커밋과 Staging은 초기화, 변경 파일은 Working Directory에 보존
- hard: 모두 삭제 (되돌릴 수 없음)

> ⚠️ 협업 중에는 `git reset` 사용을 자제해야 합니다. 특히 `--hard`는 로컬 변경사항까지 모두 삭제하기 때문에, 공동 작업 중에는 `git revert`를 사용하는 것이 안전합니다.

#### 복구 팁
```bash
git reflog   # 최근 HEAD 변경 이력 조회
```
> reset 전에 HEAD 위치를 추적하여 복원 가능

---

### `git revert`
```bash
git revert <커밋ID>
```
- 해당 커밋을 **취소하는 새로운 커밋을 생성**함
- 기록은 유지되며 협업에 안전함

#### 차이 요약
| 구분 | reset | revert |
|------|-------|--------|
| 개념 | 기록 자체 제거 | 취소 커밋 생성 |
| 협업 안정성 | 낮음 | 높음 |


## Git 브랜치 이해

- 브랜치는 커밋을 가리키는 **가벼운 포인터**
- 독립적인 개발 라인 구축 가능

### 브랜치 명명 예시
- `develop`: 전체 개발 진행
- `feat/front/dashboard`: 프론트엔드 작업
- `feat/back/login`: 백엔드 기능 작업
- `deploy`: 배포용

### 브랜치 명령어
```bash
git branch                   # 로컬 브랜치 목록
git branch -r               # 원격 브랜치 목록

git branch <이름>           # 브랜치 생성
git branch <이름> <커밋ID>  # 특정 커밋 기준 생성

git branch -d <이름>        # 병합된 브랜치 삭제
git branch -D <이름>        # 강제 삭제

git switch <이름>           # 브랜치 이동
git switch -c <이름>        # 생성 + 이동
```
> 또는 `git checkout -b <브랜치>`도 사용 가능

#### `git switch` vs `git checkout` 비교표

| 명령어 | 용도 | 특징 |
|--------|------|------|
| `git switch` | 브랜치 전환 | Git 2.23부터 도입, 명확하고 안전함 |
| `git checkout` | 브랜치 전환 + 파일 복원 | 기능이 혼합되어 헷갈릴 수 있음 |
| `git checkout -b` | 새 브랜치 생성 및 이동 | `git switch -c`와 동일 기능 |
| `git switch -c` | 새 브랜치 생성 및 이동 | `checkout -b`보다 명확하고 권장됨 |


## Git 병합 (merge)

> Git에서 브랜치를 병합할 때는 두 커밋의 변경 내역을 하나로 합치는 과정을 거칩니다.  
> 하지만 두 브랜치에서 **동일한 파일의 같은 부분을 수정**한 경우에는 Git이 자동 병합을 하지 못하고 충돌(conflict)이 발생합니다.

```bash
git switch main   # 병합 대상 브랜치로 이동
git merge <기능브랜치>
```
- Fast-forward: 직선 이동
- 3-way Merge: 공통 조상 기준으로 병합 커밋 생성

> 충돌 발생 시 `<<<<<<<` 표시된 부분 수동 수정 필요


### 병합 충돌 (Merge Conflict)

- 대표적인 충돌 예시:
  ```bash
  git merge 기능브랜치
  # CONFLICT (content): Merge conflict in example.md
  ```
- 충돌이 발생하면 해당 파일 내에 아래처럼 표기됩니다:
  ```
  <<<<<<< HEAD
  현재 브랜치의 내용
  =======
  병합하려는 브랜치의 내용
  >>>>>>> 기능브랜치
  ```
- 이 부분을 수동으로 수정한 후:
  ```bash
  git add <충돌해결한 파일>
  git commit  # 또는 git merge --continue
  ```
- 에디터가 열리면 메시지를 저장하고 닫으면 충돌 해결이 완료됩니다.

> ⚠️ 충돌 해결 시엔 반드시 `<<<<<<<`, `=======`, `>>>>>>>`를 제거한 뒤 **하나의 최종 내용만 남겨야 함**

---

## Git Rebase 충돌 해결 실습

> `git pull --rebase` 또는 `git rebase 브랜치명`으로 히스토리를 정리하려 할 때도 충돌이 발생할 수 있습니다.

### 상황 예시:
```bash
git pull --rebase origin main
# CONFLICT (content): Merge conflict in example.md
```

### 해결 절차:
1. 충돌 파일 열기 → `<<<<<<<`, `=======`, `>>>>>>>` 구간 수정
2. 수정한 파일 저장 및 스테이징:
```bash
git add example.md
```
3. 리베이스 계속 진행:
```bash
git rebase --continue
```
4. 에디터가 열리면 커밋 메시지 저장:
```vim
:wq    # Vim일 경우 저장 및 종료
```
5. 모두 완료되면 GitHub에 푸시:
```bash
git push
```

> 💡 `git rebase --abort` 명령으로 충돌 해결을 취소하고 원래 상태로 되돌릴 수도 있습니다.


## GitHub 협업 워크플로우: Fork → Pull Request

> 오픈소스 프로젝트나 협업 시 가장 널리 사용되는 GitHub 기반 작업 방식입니다.

### 전체 흐름 요약
1. 원본 저장소(Fork 대상)를 **Fork**하여 내 GitHub 계정으로 복사
2. Fork한 저장소를 **로컬에 clone**
3. 로컬에서 브랜치를 만들고 수정 및 커밋
4. GitHub 원격 저장소로 **push**
5. GitHub 웹사이트에서 **Pull Request 생성**

---

### Fork vs Shared Repository Model
| 모델 | 설명 | 사용 예시 |
|------|------|-----------|
| Shared Repository | 모든 기여자가 같은 저장소에서 작업 | 사내 프로젝트, 소규모 팀 협업 |
| Fork & PR | 기여자가 저장소를 복제 후 기여 | 오픈소스, 외부 협업 |

---

### 실전 명령어 흐름
```bash
git clone https://github.com/내계정/레포.git
cd 레포
git switch -c feat/my-feature
# 작업 후
git add .
git commit -m "feat: 기능 추가"
git push origin feat/my-feature
```

→ 이후 GitHub에서 원본 저장소로 Pull Request 제출

> 💡 PR에는 설명, 관련 이슈, 리뷰 요청 등을 포함할 수 있음

---

## Git Stash: 임시 저장소

> 브랜치를 바꾸기 전에 변경 사항을 저장하고 싶을 때 사용

### 주요 명령어:
```bash
git stash            # 현재 변경사항 임시 저장
git stash list       # 저장된 stash 목록 보기
git stash apply      # 가장 최근 stash 복원 (목록은 유지)
git stash pop        # 가장 최근 stash 복원 + 제거
```

> 💡 `stash`는 일시적인 저장소로, 빠르게 브랜치를 전환해야 할 때 유용합니다.


## 6단계: 커밋 히스토리 시각화

```bash
git log --oneline --graph --all
```
- 커밋 요약 보기 (SHA-1 해시, 메시지)
- Git은 **DAG (Directed Acyclic Graph)** 기반 구조로 커밋과 브랜치를 표현함


## 7단계: GitHub 원격 저장소 등록

```bash
git remote add origin https://github.com/사용자명/레포이름.git
```
- `origin`이라는 이름으로 원격 저장소 등록
- 확인: `git remote -v`

> 제거: `git remote remove origin`


## 8단계: 원격 저장소 연결 확인

```bash
git remote -v           # fetch/push 주소 확인
git remote show origin # 브랜치 추적 상태, fetch 대상 등 출력
git remote get-url origin # URL만 출력
```


## 9단계: GitHub에 Push

```bash
git push -u origin main
```
- `-u` 또는 `--set-upstream`은 로컬 브랜치(main)를 원격 브랜치(origin/main)와 **연결**함. 이후부터는 `git push` 또는 `git pull`만 입력해도 해당 브랜치로 자동 연결됨.
- 최초 1회 설정 필요

> 이후에는 단순히 `git push`, `git pull`만으로 연동

---

##  전체 요약 도식: Git 실행 순서 흐름

> 각 단계별 명령어와 간단 설명을 함께 보여주는 Git 실전 흐름 요약입니다.

```bash
# 1단계: 저장소 시작
$ git clone <repo-url>        # 원격 저장소 복제
# 또는
$ git init                    # 새 로컬 저장소 초기화

# 2단계: 상태 확인
$ git status                  # 변경된 파일, 추적 상태 등 확인

# 3단계: 작업
# (코드/파일 직접 수정)

# 4단계: 스테이징
$ git add .                   # 전체 변경사항 스테이징

# 5단계: 커밋
$ git commit -m "커밋 메시지"  # 변경 내역을 버전으로 기록

# 6단계: 브랜치 작업
$ git branch <브랜치명>       # 브랜치 생성
$ git switch <브랜치명>       # 브랜치 전환

# 7단계: 병합 or 리베이스
$ git merge <브랜치명>        # 병합
# 또는
$ git rebase <브랜치명>       # 리베이스

# 8단계: 충돌 발생 시
# (파일 수동 수정)
$ git add <수정된 파일>
$ git commit / git rebase --continue

# 9단계: 원격 저장소 연결
$ git remote add origin <repo-url>  # 원격 저장소 등록

# 10단계: 푸시
$ git push -u origin main     # 로컬 브랜치를 원격으로 업로드 및 연결

# 11단계: 최신 내용 동기화
$ git pull origin main        # 원격 브랜치 내용 받아오기
```
→ 최신 변경사항을 원격에서 가져와 병합
```