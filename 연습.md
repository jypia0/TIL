1단계: 저장소 시작, 원격 저장소 등록
git clone <repo-url>(원격 저장소 복제)(git init, git remote add origin <repo-url>, git fetch, git checkout 등 기본 브랜치 설정까지 함께 처리)
또는 git init(새 로컬 저장소 초기화)(이 경우엔git remote add origin <repo-url>로 원격 저장소 등록 필수)
+ git status (수정/삭제/생성 전 상태 확인)

! 2단계: 작업(코드/파일 직접 수정)
+git status (어떤 파일이 변경/추가됐는지 다시 확인)

! 3단계: 스테이징
git add .(전체 변경사항 스테이징)
+git status (스테이징 성공 여부 확인, 커밋 전 커밋해도 되는 상태인지 최종 확인)

! 4단계: 커밋
git commit -m "커밋 메시지"(변경 내역을 버전으로 기록)

5단계: 브랜치 작업
git branch <브랜치명>       # 브랜치 생성
또는 git switch <브랜치명>       # 브랜치 전환

6단계: 병합 or 리베이스
git merge <브랜치명>(병합)
또는 git rebase <브랜치명>(리베이스)
+git status (충돌 여부 확인)

7단계: 충돌 발생 시
(파일 수동 수정 후)
git add <수정된 파일>
git commit / git rebase --continue
+git status (깨끗한지 확인)

! 8단계: 푸시, 브랜치 연결
git push
git pull 
(처음 연결 시 git push -u origin main으로 로컬 브랜치를 원격으로 업로드 및 연결)

9단계: 최신 내용 동기화(다중 브랜치 협업 시)
git pull origin main (여러 원격 브랜치 중 특정 브랜치 내용 받아오기)











## 1. Fast-Forward
- 빨리감기처럼 브랜치가 가리키는 커밋을 앞으로 이동시키는 방법

## 2. 3-way Merge
- 각 브랜치의 커밋 두 개와 공통 조상 하나를 사용하여 병합하는 방법

## 3. Merge Conflict
- 두 브랜치에서 같은 부분을 수정한 경우, Git이 어느 브랜치의 내용으로 작성해야 하는지 판단하지 못 하기 때문에 Conflict 발생
- 보통 **같은 파일의 같은 부분**을 수정했을 때 자주 발생
- 충돌이 발생한 부분은 작성자가 직접 해결
- 충돌 해결 후, 병합된 내용을 기록한 Merge Commit 생성
- 서로 다른 파일을 수정 후 병합하는 경우 &rarr; automerging



# Git Workflow
- Branch와 원격 저장소를 이용해 협업을 하는 두 가지 방법
  - 원격 저장소 소유권O &rarr; Shared repository model
  - 원격 저장소 소유권X &rarr; Fork & Pull model

## Shared repository model
- 원격 저장소가 자신의 소유이거나 Collaborator로 등록되어 있는 경우
- master 브랜치에 직접 개발하는 것이 아니라, 기능 별로 브랜치를 따로 만들어 개발
- Pull Request를 사용하여 팀원 간 변경 내용에 대한 소통 진행




git flow (Branch Management)
- 소스코드를 관리하고 배포하기 위한 브랜치 관리 전략
- 대표적인 모델 (5가지 브랜치를 사용)
 - Master : 제품으로 출시되는 Branch, Production의 개념
- Develop : 다음 출시 버전을 개발하는 Branch
- Feature : 기능을 개발하는 Branch, 주로 이 브랜치에서 개발
- Release : 이번 출시 버전을 준비하는 Branch, QA 진행 (Deploy)
- Hotfix : 출시 버전에서 발생한 버그를 수정하는 Branch

Git Flow 활용 개발 시나리오
- 처음에 Master(Main)과 Develop 생성
- 새로운 추가 작업은 Develop에서 Feature Branch를 생성
- Feature는 Develop으로 Merge(이 때 Develop의 최신 상태를 확인)
- QA를 위해 Develop에서 Release Branch 생성
- QA에서 발생한 버그는 Release에서 수정
- QA가 끝나면 Release에서 Develop / Master (Main)으로 각각 Merge
- Hotfix는 Master에서 생성하여 수정한 뒤, Master, Develop에 각각 Merge
- QA를 진행할 때 Release(Deploy) branch는 test서버에 배포해놓고 수행
- Master Branch의 경우에는 운영서버에 배포되도록 설정
Git Flow 응용
- Branch 이름은 사내 컨벤션에 맞게 적용 (Master -> Main, Release -> Deploy)
- Master - Hotfix - Release - Develop - Feature
- Feature의 경우에는 개발자별로 다양한 개발을 할 수 있도록 하기 위해 Feature의 이름을 세분화
- ex) feat/back/login, feat/front/dashboard, issue/#1



Issue Tracking
- 이슈 관리를 지원하는 원격저장소 플랫폼의 경우 (ex. GitHub, 
GitLab) issue tracking을 지원
- Issue id를 commit message에 입력하면 관련 링크로 이동할 수 있
도록 하이퍼링크
- 이 때, 이슈를 나타내는 기호는 #
- Issue 기반으로 개발하는 것을 IDD (Issue-driven Development)
라고 함
- Issue에는 Task를 별도로 생성하여 할 일을 관리할 수 있음 (단, 
Issue 목록에 추가됨, Sub Issue라고 보면 됨)
- 이슈 목록에 추가되는 것이 싫다면, description에 markdown 체크
리스트 문법을 활용하는 것도 괜찮음 ex) - [ ] To do
- Linked Items는 특정 Issue와 연결 가능 (에러 수정 Issue 등 연결 
필요 시 사용, 혹은 큰 Issue -> 세부 Issue로 연결하여 관리하는 법 등)
- 프로젝트 관리 도구 (jira)를 Issue 대신하여 사용하기도 함
Commit Convention
- 커밋 컨벤션은 개발 내용에 대한 이해와 추적을 쉽게 하기 위한 목적
- Issue와 Merge Request를 넣어서 추적 가능
- COMMIT_TYPE (예시)
- feat : 새로운 기능 추가
- fix : 버그 수정
- docs : 문서 추가 및 수정
- style : 코드 포맷팅, 세미콜론 누락, 오타 수정 등
- test : 테스트 코드
- refactor : 코드 리팩토링
- chore : 빌드 업무 수정, 패키지 매니저 수정
- COMMIT_SUMMARY (예시)
- 영어로 작성 (or 한글로 작성)
- 마침표를 붙이지 않음
- 50자를 넘기지 않음
병합 & 충돌 관리 (Merge Request)
- git flow에 의해 브랜치를 구분하여 개발을 진행하면, 그것을 상위 브
랜치에 병합 해야함. 
- 이것을 Merge라고 하고, 협업 할 때 버전 관리나 충돌을 해결, 변경
사항을 공유하기 위한 목적 등으로 Merge Request(Pull Request)를 
날림.
- MR, PR의 경우 제목은 병합하는 commit들을 요약
- 상세 내용의 경우 커밋에 대한 세부 설명이나 특히 리뷰를 요청할 부
분을 남겨놓을 수 있음.
- 코드 리뷰는 Merge Request에서 주로 진행
- Reviewer에 코드 리뷰 대상자를 설정
- Reviewer는 change 내용을 보고 review를 진행할 수 있음
- 병합 중, 버전 간의 수정한 파일이 겹치면 충돌이 발생할 수 있음
- 해결 방법은 충돌된 두 버전에서 충돌된 부분에 대한 처리를 하는 것
- 로컬에서 충돌을 해결한 뒤 이를 해당 branch에 commit, merge
- 최근에는 충돌이 났을 경우 해결할 수 있도록 웹 IDE를 지원해주기 
때문에, 충돌 해결 후 merge
깃 관리
Management
.gitignore (★매우 중요★)
- 깃에서 관리하지 않을 파일들 목록 (데이터, 파일, 이미지, 비밀)
- 특정 파일 혹은 폴더까지의 상대경로를 지정
- 모든 문자열 : *
- .png로 끝나는 모든 파일을 제외 = *.png
- image 폴더의 모든 파일 제외 = image/*
- secret이 들어간 모든 파일 제외 = *secret*
- gitignore.io 에서 템플릿을 생성하여 사용
- 폴더 생성 후 특정 파일 없이 깃에 업로드할 시 사용 (폴더 구조를 
잡을 때 주로 사용)
.gitkeep
README.md
- 가이드라인, 안내문, 설명서, 지침서
- 폴더별로 README 마크다운 파일을 작성하면 원격저장소에서 기
본적으로 하단에 파싱하여 보여줌
- https://shields.io/ (사용 언어, 프레임워크, 기술, 배포 뱃지)
- 예) https://img.shields.io/badge/python-3.10-blue
- https://www.emojiengine.com/en/ (이모지)
 - 마크다운 작성법
- 깃허브 README 템플릿
- Awesome README
- 패키지명
- 패키지 한 줄 설명
- Dependency
- 설치
- 사용법
- 패키지 구조 (주요 기능, 패키지, 모듈)
- 개인 패키지는 README를 자유롭게 구성하되, 해당 패키지
를 사용하기 용이하도록 작성
- 각 폴더별로 추가 작성
- 모듈 별 상세 설명, 사용방법, 함수, 클래스의 파라미터, 반환되
는 값
패키지 README 작성법
- 파이썬 패키지 관리를 위한 파일
- 파이썬 패키지와 사용 버전들을 나열
requirements.txt
- 파이썬 환경에서 pip freeze > requirements.txt 로 생성
- pip install -r requirements.txt 로 패키지 설치



